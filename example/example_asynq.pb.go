// Code generated by protoc-gen-go-asynq. DO NOT EDIT.
// versions:
// protoc-gen-go-asynq v1.0.7

package example

import (
	context "context"
	json "encoding/json"
	asynqx "github.com/amzapi/protoc-gen-go-asynq/asynqx"
	asynq "github.com/hibiken/asynq"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	time "time"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the asynq package it is being compiled against.
var _ = new(time.Time)
var _ = new(context.Context)
var _ = new(json.RawMessage)
var _ = new(asynq.Task)
var _ = new(emptypb.Empty)
var _ = new(proto.Message)
var _ = new(asynqx.Server)

const UserQueueName = "user"

type UserTaskServer interface {
	CreateUser(context.Context, *CreateUserPayload) error
	UpdateUser(context.Context, *UpdateUserPayload) error
}

func RegisterUserTaskServer(s *asynqx.Server, srv UserTaskServer) {
	s.HandleFunc("user:create", _User_CreateUser_Task_Handler(srv))
	s.HandleFunc("user:update", _User_UpdateUser_Task_Handler(srv))
}

func _User_CreateUser_Task_Handler(srv UserTaskServer) func(context.Context, *asynq.Task) error {
	return func(ctx context.Context, task *asynq.Task) error {
		var in CreateUserPayload
		if err := json.Unmarshal(task.Payload(), &in); err != nil {
			return err
		}
		return srv.CreateUser(ctx, &in)
	}
}

func _User_UpdateUser_Task_Handler(srv UserTaskServer) func(context.Context, *asynq.Task) error {
	return func(ctx context.Context, task *asynq.Task) error {
		var in UpdateUserPayload
		if err := json.Unmarshal(task.Payload(), &in); err != nil {
			return err
		}
		return srv.UpdateUser(ctx, &in)
	}
}

type UserSvcTask struct{}

var UserTask UserSvcTask

func (j *UserSvcTask) CreateUser(in *CreateUserPayload, opts ...asynq.Option) (*asynq.Task, error) {
	payload, err := json.Marshal(in)
	if err != nil {
		return nil, err
	}
	opts = append(opts, asynq.Timeout(30*time.Second))
	opts = append(opts, asynq.MaxRetry(10))
	opts = append(opts, asynq.Timeout(60*time.Second))
	opts = append(opts, asynq.Unique(3600*time.Second))
	opts = append(opts, asynq.Queue(UserQueueName))
	task := asynq.NewTask("user:create", payload, opts...)
	return task, nil
}

func (j *UserSvcTask) UpdateUser(in *UpdateUserPayload, opts ...asynq.Option) (*asynq.Task, error) {
	payload, err := json.Marshal(in)
	if err != nil {
		return nil, err
	}
	opts = append(opts, asynq.Timeout(60*time.Second))
	opts = append(opts, asynq.MaxRetry(10))
	opts = append(opts, asynq.Timeout(60*time.Second))
	opts = append(opts, asynq.Unique(3600*time.Second))
	opts = append(opts, asynq.Queue(UserQueueName))
	task := asynq.NewTask("user:update", payload, opts...)
	return task, nil
}

type UserTaskClient interface {
	CreateUser(ctx context.Context, req *CreateUserPayload, opts ...asynq.Option) (info *asynq.TaskInfo, err error)
	UpdateUser(ctx context.Context, req *UpdateUserPayload, opts ...asynq.Option) (info *asynq.TaskInfo, err error)
}

type UserTaskClientImpl struct {
	cc *asynq.Client
}

func NewUserTaskClient(client *asynq.Client) UserTaskClient {
	return &UserTaskClientImpl{client}
}

func (c *UserTaskClientImpl) CreateUser(ctx context.Context, in *CreateUserPayload, opts ...asynq.Option) (*asynq.TaskInfo, error) {
	task, err := UserTask.CreateUser(in, opts...)
	if err != nil {
		return nil, err
	}
	info, err := c.cc.Enqueue(task)
	if err != nil {
		return nil, err
	}
	return info, nil
}

func (c *UserTaskClientImpl) UpdateUser(ctx context.Context, in *UpdateUserPayload, opts ...asynq.Option) (*asynq.TaskInfo, error) {
	task, err := UserTask.UpdateUser(in, opts...)
	if err != nil {
		return nil, err
	}
	info, err := c.cc.Enqueue(task)
	if err != nil {
		return nil, err
	}
	return info, nil
}

const BookQueueName = "book"

type BookTaskServer interface {
	CreateBook(context.Context, *CreateBookPayload) error
	UpdateBook(context.Context, *UpdateBookPayload) error
}

func RegisterBookTaskServer(s *asynqx.Server, srv BookTaskServer) {
	s.HandleFunc("book:create", _Book_CreateBook_Task_Handler(srv))
	s.HandleFunc("book:update", _Book_UpdateBook_Task_Handler(srv))
}

func _Book_CreateBook_Task_Handler(srv BookTaskServer) func(context.Context, *asynq.Task) error {
	return func(ctx context.Context, task *asynq.Task) error {
		var in CreateBookPayload
		if err := json.Unmarshal(task.Payload(), &in); err != nil {
			return err
		}
		return srv.CreateBook(ctx, &in)
	}
}

func _Book_UpdateBook_Task_Handler(srv BookTaskServer) func(context.Context, *asynq.Task) error {
	return func(ctx context.Context, task *asynq.Task) error {
		var in UpdateBookPayload
		if err := json.Unmarshal(task.Payload(), &in); err != nil {
			return err
		}
		return srv.UpdateBook(ctx, &in)
	}
}

type BookSvcTask struct{}

var BookTask BookSvcTask

func (j *BookSvcTask) CreateBook(in *CreateBookPayload, opts ...asynq.Option) (*asynq.Task, error) {
	payload, err := json.Marshal(in)
	if err != nil {
		return nil, err
	}
	opts = append(opts, asynq.Timeout(30*time.Second))
	opts = append(opts, asynq.MaxRetry(10))
	opts = append(opts, asynq.Timeout(60*time.Second))
	opts = append(opts, asynq.Unique(3600*time.Second))
	opts = append(opts, asynq.Queue(BookQueueName))
	task := asynq.NewTask("book:create", payload, opts...)
	return task, nil
}

func (j *BookSvcTask) UpdateBook(in *UpdateBookPayload, opts ...asynq.Option) (*asynq.Task, error) {
	payload, err := json.Marshal(in)
	if err != nil {
		return nil, err
	}
	opts = append(opts, asynq.Timeout(60*time.Second))
	opts = append(opts, asynq.MaxRetry(10))
	opts = append(opts, asynq.Timeout(60*time.Second))
	opts = append(opts, asynq.Unique(3600*time.Second))
	opts = append(opts, asynq.Queue(BookQueueName))
	task := asynq.NewTask("book:update", payload, opts...)
	return task, nil
}

type BookTaskClient interface {
	CreateBook(ctx context.Context, req *CreateBookPayload, opts ...asynq.Option) (info *asynq.TaskInfo, err error)
	UpdateBook(ctx context.Context, req *UpdateBookPayload, opts ...asynq.Option) (info *asynq.TaskInfo, err error)
}

type BookTaskClientImpl struct {
	cc *asynq.Client
}

func NewBookTaskClient(client *asynq.Client) BookTaskClient {
	return &BookTaskClientImpl{client}
}

func (c *BookTaskClientImpl) CreateBook(ctx context.Context, in *CreateBookPayload, opts ...asynq.Option) (*asynq.TaskInfo, error) {
	task, err := BookTask.CreateBook(in, opts...)
	if err != nil {
		return nil, err
	}
	info, err := c.cc.Enqueue(task)
	if err != nil {
		return nil, err
	}
	return info, nil
}

func (c *BookTaskClientImpl) UpdateBook(ctx context.Context, in *UpdateBookPayload, opts ...asynq.Option) (*asynq.TaskInfo, error) {
	task, err := BookTask.UpdateBook(in, opts...)
	if err != nil {
		return nil, err
	}
	info, err := c.cc.Enqueue(task)
	if err != nil {
		return nil, err
	}
	return info, nil
}
